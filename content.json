{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-11-16T14:12:04.472Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"​ 灵台方寸山，斜月三星洞"},{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-16T15:30:54.408Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面先对象高级编程","slug":"面先对象高级编程","date":"2021-12-13T15:00:51.000Z","updated":"2021-12-13T17:20:35.693Z","comments":true,"path":"2021/12/13/面先对象高级编程/","link":"","permalink":"http://hanke8.cloud/2021/12/13/%E9%9D%A2%E5%85%88%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","excerpt":"","text":"面向对象高级编程（上）头文件与类的声明 头文件声明采用防卫式 #ifndef #define #endif 作用：防止重复include 如果类的成员函数声明和定义都在类内，则为内联函数。若定义在类外，则需要加inline关键字才为内联函数。（注：加了inline也不一定能成为内联，具体还得看编译器自己判断(inline只是为编译器一个建议)） 若成员函数不修改成员数据，建议后面加个const 否则当用户使用类，在前面加了const时，再调用类函数就会报错。(类设计的不够好，考虑不充分) 友元函数可直接访问私有成员。 同一个class的各个 objects 互为友元 123int complex::func(const complex&amp; param) &#123; return param.re + param.im; // complex是复数类，其中re是实部，im是虚部（都是私有）&#125; 构造函数 构造函数尽量采用初始化列的方式 若写在构造函数内部，则成了赋值，效率不高，因为进入函数体之前就进行了默认初始化。 另外就是派生类对父类成员进行初始化必须在初始化列，因为先要初始化父类，之后才进入派生类的构造函数内部。 拷贝构造函数的参数只能是类的引用 首先肯定不能是指针。拷贝，顾名思义是要拷贝相同类型的东西，所以参数只能是类，而不能是类的指针。 其次不能传值。因为传值又会调用拷贝构造函数，造成无限递归。 构造函数可以是private，用于单例模式 向外提供一个返回静态实例对象的函数，注意并发时得加锁。 参数和返回值尽量传引用（注：不能返回局部变量的引用） new和delete new被编译器解释为： 先调用operator new(这是一个函数，里面调用的是malloc)，为对象分配内存。 再将malloc返回的指针进行类型转换。 最后调用对象的构造函数，对分配的内存进行初始化。 delete被编译器解释为： 先调用对象的析构函数。 在调用operator delete(这是一个函数，里面调用的是free)，释放之前为对象分配的内存。 new xxx[] 和 delete[] xxx要配对使用 因为delete[] xxx对调用n次析构函数，最后再释放对象内存。 析构函数里面可能需要释放构造函数里面new的内存（和对象内存是两码事）。 若new xxx[] ，直接delete xxx，则可能会导致对象构造函数内new的内存泄露。","categories":[{"name":"视频","slug":"视频","permalink":"http://hanke8.cloud/categories/%E8%A7%86%E9%A2%91/"}],"tags":[{"name":"侯捷老师视频","slug":"侯捷老师视频","permalink":"http://hanke8.cloud/tags/%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E8%A7%86%E9%A2%91/"}]},{"title":"原地哈希","slug":"原地哈希","date":"2021-12-10T11:49:23.000Z","updated":"2021-12-10T12:04:41.939Z","comments":true,"path":"2021/12/10/原地哈希/","link":"","permalink":"http://hanke8.cloud/2021/12/10/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/","excerpt":"","text":"模板1234567891011// 解法：原地哈希// 把输入的nums当做一个哈希表for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) &#123; if(nums[i] != nums[nums[i]-1]) &#123; // 原地哈希模板 swap(nums[i], nums[nums[i]-1]); i--; &#125; &#125;&#125; 相关题目lc41.缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 代码： 1234567891011121314151617181920class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &lt;= 0) continue; if(nums[i] &gt;= n) continue; if(nums[i] != i+1) &#123; if(nums[i] != nums[nums[i]-1]) &#123; swap(nums[i], nums[nums[i]-1]); i--; &#125; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) return i+1; &#125; return n+1; &#125;&#125;; lc442.数组中重复的数据 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 代码： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; // 解法：原地哈希 vector&lt;int&gt; res; int n = nums.size(); for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) &#123; if(nums[i] != nums[nums[i]-1]) &#123; // 原地哈希模板 swap(nums[i], nums[nums[i]-1]); i--; &#125; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) res.push_back(nums[i]); &#125; return res; &#125;&#125;; lc448.找出所有数组中消失的数字 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 代码： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; // 解法：原地哈希 // 把输入的nums当做一个哈希表 int n = nums.size(); for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) &#123; if(nums[i] != nums[nums[i]-1]) &#123; // 原地哈希模板 swap(nums[i], nums[nums[i]-1]); i--; &#125; &#125; &#125; vector&lt;int&gt; res; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i+1) res.push_back(i+1); &#125; return res; &#125;&#125;; 剑指 Offer 03. 数组中重复的数字 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 代码： 1234567891011121314151617class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] != i) &#123; if(nums[nums[i]] == nums[i]) &#123; return nums[i]; &#125; else &#123; swap(nums[nums[i]], nums[i]); i--; &#125; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"原地哈希","slug":"原地哈希","permalink":"http://hanke8.cloud/tags/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/"}]},{"title":"C++虚指针vptr","slug":"C-虚指针vptr","date":"2021-12-10T07:38:45.000Z","updated":"2021-12-10T07:46:34.926Z","comments":true,"path":"2021/12/10/C-虚指针vptr/","link":"","permalink":"http://hanke8.cloud/2021/12/10/C-%E8%99%9A%E6%8C%87%E9%92%88vptr/","excerpt":"","text":"虚函数表 当类中声明虚函数时，编译器会在类中生成一个虚函数表。 虚函数表是一个存储成员函数指针的数据结构。 虚函数表由编译器自动生成与维护。 虚指针 在实现多态的过程中，父类和派生类都有vptr指针，指向对应的虚函数表。 对象在创建时，由编译器对vptr指针进行初始化。只有当对象的构造完全结束后vptr的指向才最终决定下来。 定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因。） 参考 https://www.cnblogs.com/yangguang-it/p/6547314.html","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"虚指针","slug":"虚指针","permalink":"http://hanke8.cloud/tags/%E8%99%9A%E6%8C%87%E9%92%88/"}]},{"title":"《图解HTTP》第二章","slug":"图解HTTP第二章","date":"2021-12-10T02:55:43.000Z","updated":"2021-12-10T03:41:34.764Z","comments":true,"path":"2021/12/10/图解HTTP第二章/","link":"","permalink":"http://hanke8.cloud/2021/12/10/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"报文格式 请求报文： 请求行：请求方法 url 协议版本、请求头、请求体 响应报文： 响应行：协议版本 状态码 状态码的解释、响应头、响应体 请求方法 GET：获取资源 POST：提交数据 HEAD：获取请求资源的头部信息 OPTIONS：查询服务器支持哪些请求方法 PUT：上传文件（注：自身不带验证机制，存在安全问题，一般不用） DELETE：删除文件（注：自身不带验证机制，存在安全问题，一般不用） TRACE：追踪路径，查询请求过程发生的一系列操作(因为中间可能会经过代理服务器)，主要用于测试或诊断 CONNECT：要求与代理服务器通信时建立隧道 无状态 http是一种无状态协议，不记录之前的通信状态。 为了实现保持状态的功能，使用cookie技术来进行状态管理。 cookie技术通过在请求和响应报文中写入cookie信息来记录客户端的状态： 第一次通信，服务器会在响应报文头部中写入Set-Cookie: sid=... 客户端保存cookie值，在之后的请求报文中携带cookie值 短连接 短连接：在http早期版本，每进行一次http通信，都需要进行一次tcp连接。 持久连接：一次tcp连接，可以进行多次http请求、响应，HTTP/1.1默认支持keep-alive 减少了tcp重复建立、断开的额外开销。 持久化连接使得可以进行流水线模式，能够并行发送多个http请求，而不用一个一个等待响应了。 使得http请求和响应能更快结束，因此Web页面的响应速度也就提高了。","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《图解HTTP》","slug":"《图解HTTP》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/"}]},{"title":"docker学习","slug":"docker学习","date":"2021-12-09T14:37:36.000Z","updated":"2021-12-09T14:38:26.738Z","comments":true,"path":"2021/12/09/docker学习/","link":"","permalink":"http://hanke8.cloud/2021/12/09/docker%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 架构 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 docker 容器使用 容器 ID：对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。 获取镜像： docker pull 镜像名 启动容器： docker run -参数 镜像名 命令 例如：docker run -it ubuntu:15.10 /bin/bash 参数解释： docker： Docker 的二进制执行文件。 run： 与前面的 docker 组合来运行一个容器。 -i： 交互式操作。 -t： 终端。 ubuntu:15.10： 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。 /bin/bash： 放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 补充：-d为后台运行，-P为容器内部端口随机映射到主机的高端口，-p为容器内部端口绑定到指定的主机端口 查看容器： docker ps 进入容器： docker exec/attach 容器id，推荐使用 docker exec，因为它退出容器终端，不会导致容器的停止。 停止容器： docker stop 容器id 启动已经停止的容器： docker start/restart 容器id 删除容器： docker rm -f 容器id docker 镜像使用 获取镜像： 当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。如果想预先下载这个镜像，可以使用 docker pull 列出镜像： docker images 删除镜像： docker rmi 镜像名 创建镜像： 先写docker file，再docker build 参考 https://www.runoob.com/docker/docker-tutorial.html","categories":[{"name":"tools","slug":"tools","permalink":"http://hanke8.cloud/categories/tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://hanke8.cloud/tags/docker/"}]},{"title":"右值引用","slug":"右值引用","date":"2021-12-06T11:13:15.000Z","updated":"2021-12-06T11:32:57.420Z","comments":true,"path":"2021/12/06/右值引用/","link":"","permalink":"http://hanke8.cloud/2021/12/06/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/","excerpt":"","text":"什么是左值、右值？ 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。 什么是左值引用、右值引用？ 引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。 左值引用： 能指向左值，不能指向右值的就是左值引用。引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。 注意：常量左值引用可以指向右值。（如：const int&amp; a = 10；） 右值引用： 右值引用的标志是&amp;&amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值。 话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 /03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。 右值引用主要用于移动语义和完美转发。（// todo） 参考 https://zhuanlan.zhihu.com/p/335994370 http://c.biancheng.net/view/7829.html","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"右值引用","slug":"右值引用","permalink":"http://hanke8.cloud/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"}]},{"title":"《深度探索C++对象模型》 第二章(构造函数语意学)","slug":"深度探索C++对象模型 第二章","date":"2021-11-29T03:23:07.000Z","updated":"2021-12-13T13:08:42.182Z","comments":true,"path":"2021/11/29/深度探索C++对象模型 第二章/","link":"","permalink":"http://hanke8.cloud/2021/11/29/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"第二章 构造函数语意学Default Constructor 的构造操作C++新手常见的 2 个误区 ERROR: 如果 class 没有定义 default constructor 编译器就一定会提供一个。 ERROR: 编译器合成出来的默认构造函数会明确设定每一个 data member 的默认值。 验证 没必要合成就不去合成，因为合成默认(拷贝)构造函数即浪费内存又浪费时间，并且函数调用还浪费时间。 反正合成的默认(拷贝)构造函数也是干的相同的事情，编译器还不如直接自己干了。 在线编译网站 编译器什么情况下会合成默认构造函数？ 首先明确一点，默认的构造函数只有在编译器需要的时候才被合成出来，当然前提是程序员没有写默认构造函数。如果写了，那编译器就不会再去合成，最多是会在用户代码前安插一些代码。 只有以下四种情况(编译器会合成默认构造函数)： 带有 Default Constructor 的 Member Class Object。(编译器需要，因为编译器需要调用成员类的构造函数) 带有 Default Constructor 的 Base Class。(编译器需要，因为编译器需要调用父类的构造函数) 带有 Virtual Function 的 Class。(编译器需要，因为编译器需要正确设置好vptr) 带有 Virtual Base Class 的 Class。**(// todo，编译器需要，因为编译器要保证虚基类在派生类中的位置在执行期准备妥当)** 注：在合成的 default constructor 中，只有 base class subobjects 和 member class objects 会被初始化。所有其他的 nonstatic data member 不会被初始化(如整数、整数指针、整数数组等)。因为这是程序员的需要，而不是编译器的需要。 成员初始化列表 以 member 声明的次序来决定初始化次序，而不是初始化列表中的排列次序来决定次序。 123456class A &#123;public: int i; int j; A(int val): j(val), i(j) &#123;&#125; // 虽然j写在了前面，但实际还是i先初始化，因为i先声明。&#125;; // 如果不注意这一陷阱，会导致程序和我们预想的不一致。 Copy Constructor 的构造操作编译器什么情况下会合成默认拷贝构造函数？ 当 class 内含一个 member object 而后者声明了（也可能由于 nontrivial 语意从而编译器真正合成出来的）一个 copy constructor 时。 当 class 继承自一个存在有 copy constructor 的 base class（同样也可能是合成）时。 当 class 声明了一个或多个 virtual functions 时。 当 class 派生自一个继承串链，其中一个或多个 virtual base classes 时。 什么时候调用拷贝构造函数？ 一个类以另一个类作为参数显示初始化。 作为函数的参数。 作为函数的返回值。","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《深度探索C++对象模型》","slug":"《深度探索C-对象模型》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"}]},{"title":"构造/析构函数可以是虚函数吗？","slug":"构造-析构函数可以是虚函数吗？","date":"2021-11-25T14:01:50.000Z","updated":"2021-11-25T14:36:25.234Z","comments":true,"path":"2021/11/25/构造-析构函数可以是虚函数吗？/","link":"","permalink":"http://hanke8.cloud/2021/11/25/%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F/","excerpt":"","text":"构造/析构函数可以是虚函数吗？结论 构造函数不可以是虚函数，也不可能成为虚函数。 当有派生类，且派生类中申请了内存，那析构函数必须是虚函数（防止内存泄露）。 解释 构造函数不能是虚函数的原因： 从vptr角度解释： 虚函数的调用要通过查找对象内部的虚指针指向的虚函数表。若构造函数是虚函数，则要去查找vptr，但此时对象没有初始化，没有vptr。 从多态角度解释： 虚函数主要是用于实现多态的，而构造函数是创建对象时自动调用的，不可能通过父类的指针或者引用去调用，完全和多态不沾边，成为虚函数没有任何意义。 析构函数： 当有派生类且派生类申请了内存时，析构函数必须要是虚函数，不然就会派生类申请的内存得不到释放，会造成内存泄露。 注：如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数。 其余情况析构函数尽量别成为虚函数，因为虚指针、虚函数表浪费内存。 参考 https://blog.csdn.net/libaineu2004/article/details/85684224 https://blog.csdn.net/qq_28584889/article/details/88749862 https://blog.csdn.net/weixin_42333471/article/details/88067951","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"构造、析构函数可以是虚函数？","slug":"构造、析构函数可以是虚函数？","permalink":"http://hanke8.cloud/tags/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F/"}]},{"title":"inline内联函数","slug":"inline内联函数","date":"2021-11-24T16:22:50.000Z","updated":"2021-11-29T03:15:59.083Z","comments":true,"path":"2021/11/25/inline内联函数/","link":"","permalink":"http://hanke8.cloud/2021/11/25/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","excerpt":"","text":"inline内联函数介绍 函数调用需要开栈 (分配内存、保存现场、准备参数、准备返回值)。 (假设某个函数经常被调用)为了解决频繁调用函数对栈内存重复开辟所带来的消耗，引入了inline修饰符，表示为内联函数。 编译器将内联函数内的代码复制到每一个使用它的地方。（有点像宏函数，但宏函数是预处理器来替换，不进行安全性检查） 注：inline可以修饰虚函数，但是当虚函数表现多态性的时候不能内联。(因为内联是编译器，多态是运行期) 用法 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。 1234567// 错误写法inline void Foo(int x, int y); // inline 仅与函数声明放在一起void Foo(int x, int y) &#123;&#125;// 正确写法void Foo(int x, int y);inline void Foo(int x, int y) &#123;&#125; // inline 与函数定义体放在一起 限制 inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数。 解释：内联函数不能是递归函数，因为内联函数是被编译器在编译的时候展开，而递归的深度在编译的时候无法确定。 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 参考 https://blog.csdn.net/zqixiao_09/article/details/50877383 https://blog.csdn.net/BjarneCpp/article/details/76044493 https://bbs.csdn.net/topics/90164538","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"inline内联函数","slug":"inline内联函数","permalink":"http://hanke8.cloud/tags/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"}]},{"title":"《Effective C++》第一章","slug":"Effective C++ 第一章","date":"2021-11-23T17:04:22.000Z","updated":"2021-11-23T17:51:58.694Z","comments":true,"path":"2021/11/24/Effective C++ 第一章/","link":"","permalink":"http://hanke8.cloud/2021/11/24/Effective%20C++%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"导读 默认的构造函数：要么没有参数，要么每个参数都有缺省值。 构造函数最好使用explicit关键字，阻止隐式类型转换(使代码更规范，防止意想不到的错误)。 拷贝构造函数的参数只能是传引用(不能是传值，也不能传指针)。解释 条款01 视 C++ 为一个语言联邦 C++ 是个多重范型编程语言：面向过程、面向对象、函数式、泛型、原编程式，所以他的规约很多，记住四个次语言可以帮助了解 C++：C、Object-Oriented C++、Template C++、STL。 条款02 尽量以 const、enum、inline 替换 #define 少用#define的理由如下： #define不会进行类型安全检查，#define AGE 25，AGE无类型，在进行预处理阶段只有AGE被替换成25的过程；而const int age = 25，age有类型(int)，在编译阶段会进行类型安全检查。 #define不提供封装性，即不存在private #define 这样的东东，无法用在class内部用#define定义class的专属常量；而class的常量可以用const来声明，比如static const int MAX_SIZE = 1024。 使用#define定义”宏函数”时，会出其不意的错误有时候，最好改用inline函数替换#define。 他们的根本差别是：前三者是编译器处理的，最后者是预处理器处理的。enum 比 const 更像 #define，比如说 const 定义通常可以求地址或引用，而 enum 不行。 inline 函数比宏多了类型安全和可预料性，一个例子是将 i++ 或 ++i 当参数传给宏时，可能导致 ++ 了多次，而传给 inline 函数则不会。 请记住： 对于单纯常量，最好使用const对象或者enum替代#define。 对于宏函数，最好使用inline函数替换。 条款03 尽可能使用 const const 可以帮助编译器侦测错误的用法。例如，令函数返回一个常量值，往往可降低因调用者错误而造成的意外，而又不至于放弃安全性和高效性。比如当比较语句少写了一个 = 时： 12// 本意是 ==，结果导致在 a * b 的临时变量上调用 operator=if (a * b = c) ... ​ 如果 operator= 返回值不是 const 会导致以上错误代码编译通过！ 条款04 确定对象被使用前已被初始化 c++规定初始化发生在进入构造函数之前。 1234567891011121314class A&#123;private: int x; int y; // 赋值 A() &#123; x = 0; // 注意！这是赋值不是初始化。（在进入构造函数之前就进行了初始化） y = 0; &#125; // 初始化 A(): x(0), y(0) &#123; // 这才是初始化，这样比赋值的效率高（因为赋值前就进行了初始化） &#125;&#125;; c++对于处于不同编译单元的non-local static对象的初始化相对顺序无明确定义。 注：local static对象是指在函数内声明定义的static对象，并通过该函数返回该对象的引用。 带来问题：比如两个源文件分别定义了non-local static对象a, b，其中a用到了b，此时b可能还未初始化。 解决方案：为避免跨编译单元的初始化次序问题，用 local static 对象代替 non-local static 对象，参考 Singleton 模式常见实现。 12345XClass&amp; GetInstance()&#123; static XClass instance; return instance;&#125; 参考 https://segmentfault.com/a/1190000038888539 《Effective C++》第一章","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Effective C++》","slug":"《Effective-C-》","permalink":"http://hanke8.cloud/tags/%E3%80%8AEffective-C-%E3%80%8B/"}]},{"title":"c++引用的本质","slug":"c-引用的本质","date":"2021-11-23T03:48:27.000Z","updated":"2021-11-23T03:55:05.259Z","comments":true,"path":"2021/11/23/c-引用的本质/","link":"","permalink":"http://hanke8.cloud/2021/11/23/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"C++ 引用的本质结论 引用的本质是一个指针常量 参考 一个reference通常是以一个指针来实现的，所以point和reference并没有本质的区别。– &lt;&lt;深度探索C++对象模型&gt;&gt; 注：Lippman 这里只是说通常的编译器实现，但是 C++标准并未给予保证。 引用的本质是一个指针常量(注意不是常量指针),指针常量的指向不可改而指向的值可以修改； 这也解释了引用为什么能够修改原来变量的值，修改值的唯一方法即是修改该地址对应的值。 – Google","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"c++引用的本质","slug":"c-引用的本质","permalink":"http://hanke8.cloud/tags/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/"}]},{"title":"拷贝构造函数参数","slug":"拷贝构造函数参数","date":"2021-11-22T10:28:06.000Z","updated":"2021-11-22T10:56:35.610Z","comments":true,"path":"2021/11/22/拷贝构造函数参数/","link":"","permalink":"http://hanke8.cloud/2021/11/22/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/","excerpt":"","text":"拷贝构造函数参数结论 拷贝构造函数的参数必须是引用 解释 为什么不能是传值？ 经典误区：或许你会回答为了减少一次内存拷贝？ 正解：传值的方式会继续调用拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。 为什么不能是传指针？ 拷贝构造函数需要传入的是一个对象，如果拷贝构造函数的参数是指针的话，这个参数就是地址而不是对象了(仅仅指向对象而已)。 所以不能用指针，作为拷贝构造函数的参数类型。 即写出传指针，那就不是拷贝构造函数了，编译器不认。 代码验证： 下面代码执行结果不会打印 ”拷贝构造函数“，说明func(a)调用的默认拷贝构造函数，即传指针的方式根本就不是拷贝构造函数。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt; // 万能头文件using namespace std;class A &#123;private: int data;public: A() &#123; cout &lt;&lt; &quot;构造函数&quot;&lt;&lt;endl; &#125; A(const A* a) &#123; data = a-&gt;data; cout &lt;&lt; &quot;拷贝构造函数&quot;&lt;&lt;endl; &#125; void func(A a) &#123; cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; A a; A b; a.func(b); return 0; &#125; 参考 https://blog.csdn.net/qq_35409955/article/details/72356370 https://www.codenong.com/cs109023805/","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"拷贝构造函数参数","slug":"拷贝构造函数参数","permalink":"http://hanke8.cloud/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"}]},{"title":"《深度探索C++对象模型》 第一章(关于对象)","slug":"深度探索C++对象模型 第一章","date":"2021-11-21T15:04:19.000Z","updated":"2021-11-23T17:52:29.250Z","comments":true,"path":"2021/11/21/深度探索C++对象模型 第一章/","link":"","permalink":"http://hanke8.cloud/2021/11/21/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"第一章 关于对象C++对象模式（The C++ Object Model）主题一个class对象在机器中是如何被表示的呢？ 分类 简单对象模型（A Simple Object Model） 表格驱动对象模型（A Table-driven Object Model） C++ 对象模型（The C++ Object Model） 简单对象模型（A Simple Object Model） 在简单模型中，一个object是一些的slots，每个slot指向一个members。Members按其声明此次序，各被指定一个slot，每一个data member或function member都有自己的一个slot。 简单理解起来就是，一个object被表示成了一个指针数组。 在这个简单模型中, members本身并不放在 object之中,只有“指向的指针”才放在 object内。这么做可以避免 ”members有不同的类型, 因而需要不同的存储空间“ 所招致的问题。 这个想法被应用到C++的 “指向成员的指针” 观念之中。 表格驱动对象模型（A Table-driven Object Model） object还是一个指针数组，不过存的是Member Data Table和Function Member Table两个表的地址。 这种模型保证了不同类型的对象具有相同的内存布局。 这个想法成为支持virtual functions的一个有效方案。 C++ 对象模型（The C++ Object Model） 在此模型中，Nonstatic data members被配置于每一个class object之内, static data members则被存放在所有的class object之外。Static和 nonstatic function members也被放在所有的class object之外, Virtual functions则以两个步骤支持之: 每一个 class产生出一堆指向 virtual functions的指针, 放在表格之中, 这个表格被称为 virtual table(vtbl)。 每一个 class obiect被添加了一个指针, 指向相关的 virtual table。 总结 ASOM和ATOM方法优点是object数据一致性(存的都是指针)，可以避免 ”members有不同的类型, 因而需要不同的存储空间“ 所招致的问题；缺点就是会带来间接性，使得存、取变得麻烦（特别是类继承时，如果在派生类里面存一个指向基类的指针）。 在C++中以类的形式实现对象之后，会增加多少布局成本？ 一般来说，不会增加任何成本。三个 data members 直接内含于一个 class object 中，就像 C 中的 struct 一样。而 member functions 虽然含在 class 的声明中，却不出现在 object 中 （更像是类命名空间中的普通函数）。看，类的封装居然没有带来任何额外的成本。 C++在内存布局以及存取时间上的主要额外负担都是由 virtual 引起的，包括： virtual function 机制：引起了保存 vtable 和透过 vtable 找到函数地址。 virtual base class 机制：引起了透过指针来找到基类的成员。 引入继承后的对象模型成本： 如果是普通的继承，父对象被直接包含在子对象里面，这样对父对象的存取也是直接进行的， 没有额外的成本。 如果是虚拟继承，则父对象会由一个指针被指出来，这样的话对父对象的存取就添加了一层间接性，必须经由一个指针来访问，添加了一次间接的额外成本。 一个对象的内存布局大小（通常由 3 部分组成）： 其 nonstatic data member 的总和大小。 任何由于字节对齐所需要的填补上去的空间。 加上了为了支持 virtual 机制而引起的额外负担。 这也印证了前面的一个结论：C++中的额外成本通常都是由于 virtual 机制所引起的。 多态的实现前言 指针类型、cast(类型转化)只影响编译器对内存的解释(大小和内容)。 实现方式 多态只能由指针或引用来实现，原因如下： 指针和引用（通常以指针来实现）的大小是固定的（一个 word），而对象的大小却是可变的。其类的指针和引用可以指向（或引用）子类，但是基类的对象永远也只能是基类，没有变化则不可能引发多态。 一个 point 或 reference 绝不会引发任何” “ 与类型有关的内存委托操作 ，在指针类型转换时 会受到的改变的只有它们所指向内存的解释方式而已。（例如指针绝不会引发 slice，因为它 们大小相同） 思考(加深理解)：","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《深度探索C++对象模型》","slug":"《深度探索C-对象模型》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"}]},{"title":"文件描述符","slug":"文件描述符","date":"2021-11-19T13:05:39.000Z","updated":"2021-11-19T13:22:03.146Z","comments":true,"path":"2021/11/19/文件描述符/","link":"","permalink":"http://hanke8.cloud/2021/11/19/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"Linux文件描述符的本质大致认识文件描述符是文件编号。 Linux 中一切皆文件，比如 C++ 源文件、视频文件、Shell脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。 一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为文件描述符（File Descriptor）。 进一步认识文件描述符是PCB内部文件描述符表的下标，与文件指针一一映射。 一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。 除了文件描述符表，系统还需要维护另外两张表： 打开文件表（Open file table） i-node 表（i-node table） 参考 http://c.biancheng.net/view/3066.html","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"文件描述符","slug":"文件描述符","permalink":"http://hanke8.cloud/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"}]},{"title":"epolloneshot事件","slug":"epolloneshot事件","date":"2021-11-19T12:17:37.000Z","updated":"2021-11-19T12:37:29.927Z","comments":true,"path":"2021/11/19/epolloneshot事件/","link":"","permalink":"http://hanke8.cloud/2021/11/19/epolloneshot%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"epoll - ET触发模式 - epolloneshot事件背景对于同一批数据我们希望在一个线程里面处理，不然容易造成混乱。 问题epoll模型的ET模式一般来说只触发一次，然而在并发程序中有特殊情况的存在，譬如当epoll_wait已经检测到socket描述符fd1，并通知应用程序处理fd1的数据，那么处理过程中该fd1又有新的数据可读，会唤醒其他线程对fd1进行操作，那么就出现了两个工作线程同时处理fd1的情况，这当然不是我们期望看到的。 解决方案epolloneshot事件，规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符。当然处理完之后线程要重置这个epolloneshot事件，进而当此描述符有事件可读时让其他进程可以处理此描述符。 关键代码1234567891011121314151617// 工作线程while( 1 ) &#123; int ret = recv( sockfd, buf, BUFFER_SIZE-1, 0 ); if( ret == 0 ) &#123; // 客户端关闭连接 close( sockfd ); printf( &quot;client closed the connection\\n&quot; ); break; &#125; else if( ret &lt; 0 ) &#123; if( errno == EAGAIN ) &#123; // 数据被读完 resetOneshot( epollfd, sockfd ); // 重置Oneshot事件 printf( &quot;read later\\n&quot; ); break; &#125; &#125; else ...略&#125; 参考 https://blog.csdn.net/hnlyyk/article/details/50946655 https://www.cnblogs.com/kex1n/p/7451069.html","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"epolloneshot","slug":"epolloneshot","permalink":"http://hanke8.cloud/tags/epolloneshot/"}]},{"title":"端口复用","slug":"端口复用","date":"2021-11-17T08:07:32.000Z","updated":"2021-11-17T08:19:08.883Z","comments":true,"path":"2021/11/17/端口复用/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/","excerpt":"","text":"端口复用背景 默认的情况下，一个端口只能被一个套接字绑定；如果一个网络应用程序的一个套接字绑定了一个端口( 占用了 8000 )，这时候，别的套接字就无法使用这个端口( 8000 )； 因为多个应用程序占用一个端口，容易发生混乱； 应用场景 （1）服务器只对外开放某一端口（80端口或其他任意少量端口），其他端口全部被封死（2）为了躲避防火墙（3）隐藏自己后门（4）转发不出端口（5）内网渗透 端口复用最常用的用途应该是防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中——那只好等等再重试了，麻烦！ 如何使用 设置socket的SO_REUSEADDR选项，即可实现端口复用： 123int opt = 1;// sockfd为需要端口复用的套接字setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;opt, sizeof(opt)); 注意点 端口复用允许在一个应用程序可以把 n 个套接字绑在一个端口上而不出错。同时，这 n 个套接字发送信息都正常，没有问题。但是，这些套接字并不是所有都能读取信息，只有最后一个套接字会正常接收数据。 端口复用的原理是与源端口占用程序监听同一端口，当复用端口有数据来时，我们可以判断是否是自己的数据包，如果是自己的，那么就自己处理，否则把数据包交给源端口占用程序处理。 在这里有个问题就是，如果你不处理数据包的归属问题的话，那么这个端口就会被端口复用程序占用，从而导致源端口占用程序无法工作。 参考 https://blog.csdn.net/tennysonsky/article/details/44062173 https://juejin.cn/post/6844903509624651790#heading-4","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"}]},{"title":"状态压缩","slug":"状态压缩","date":"2021-11-17T06:44:46.000Z","updated":"2021-11-17T07:02:08.017Z","comments":true,"path":"2021/11/17/状态压缩/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"状态压缩基本思路 用二进制表示状态 位运算 LC318.最大单词长度乘积 遍历所有的单词对，判断他们是否有同样的字母出现； 传统的做法就是用一个长度为26的数组记录每个单词出现了哪些字符；每次比较遍历复杂度是26，乘以遍历单词对O(n^2)复杂度，可能就会超时了； 一个优化的方式就是采用状态压缩，我们将每一个字母是否出现在某个单词的状态用一个int表示， int的每一位代表a-z中的每个字母是否出现过; 123456789101112131415161718192021222324252627class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; // 状态压缩： // 用一个26位的int表示每个字符是否出现。(比如...101 表示&#x27;c&#x27;和&#x27;a&#x27;出现过) // 之后再用 &amp; 运算即可知道是否有相同字符 int n = words.size(); vector&lt;int&gt; status(n, 0); for(int i = 0; i &lt; n; i++) &#123; for(char&amp; ch : words[i]) &#123; status[i] |= 1 &lt;&lt; (ch-&#x27;a&#x27;); // ch相应的位置置1 &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if( (status[i] &amp; status[j]) == 0) &#123; // &amp; 为0，表示没有相同的字符 int len = words[i].length() * words[j].length(); res = max(res, len); &#125; &#125; &#125; return res; &#125;&#125;; 复杂度：O(L+n^2)，L是全部单词长度之和;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"0-1背包","slug":"0-1背包","date":"2021-11-16T15:06:50.000Z","updated":"2021-11-16T15:37:14.927Z","comments":true,"path":"2021/11/16/0-1背包/","link":"","permalink":"http://hanke8.cloud/2021/11/16/0-1%E8%83%8C%E5%8C%85/","excerpt":"","text":"动态规划背包问题基本思路 常见于题型：考虑每个物品选或者不选； dp[i] [j] 一般定义成：前i个物品中，容量为j，怎么样； LC416.分割等和子集 看数据范围可知，dfs必定超时； 一般dfs搜索可以解决的问题，动态规划也能解决； (个人认为动态规划的本质也是搜索，基本等价于记忆化dfs) 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 动态规划：0-1背包，从前i个物品里是否能挑出刚好容量为sum/2 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(sum/2 + 1, false)); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[0][nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; // 复杂度：O(NM) M为sum/2 for(int j = 1; j &lt;= sum / 2; j++) &#123; if(nums[i] == j) &#123; dp[i][j] = true; continue; &#125; if(dp[i-1][j]) dp[i][j] = true; // 更新dp[i][j] else if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true; // 更新dp[i][j] &#125; if(dp[i][sum/2]) return true; &#125; return dp[n-1][sum/2]; &#125;&#125;; 优化： 从上面可以看出，dp[i] [j]仅于dp[i-1] [j]和dp[i-1] [j-nums[i]]有关，因此只要保存上一行即可； 进一步可以从二维优化到一维，逆序更新即可；即用当前行覆盖上一行数据；(看代码就容易明白了) 1234567891011121314151617181920212223242526class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 二维0-1背包优化成1维度; // (因为dp[i][j]仅于dp[i-1][j]和dp[i-1][j-nums[i]]有关) // (即当前行的更新仅于上一行的两个元素有关) 因此倒序更新即可 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;bool&gt; dp(sum/2 + 1, false); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; for(int j = sum/2; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j-nums[i]]; // 当前行的dp[j], 利用上一行的dp[j]和dp[j-nums[i]]来更新 &#125; if(dp[sum/2]) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"}]},{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-11-16T15:36:52.108Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-11-16T15:34:38.638Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"视频","slug":"视频","permalink":"http://hanke8.cloud/categories/%E8%A7%86%E9%A2%91/"},{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"},{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"tools","slug":"tools","permalink":"http://hanke8.cloud/categories/tools/"},{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"侯捷老师视频","slug":"侯捷老师视频","permalink":"http://hanke8.cloud/tags/%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E8%A7%86%E9%A2%91/"},{"name":"原地哈希","slug":"原地哈希","permalink":"http://hanke8.cloud/tags/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/"},{"name":"虚指针","slug":"虚指针","permalink":"http://hanke8.cloud/tags/%E8%99%9A%E6%8C%87%E9%92%88/"},{"name":"《图解HTTP》","slug":"《图解HTTP》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/"},{"name":"docker","slug":"docker","permalink":"http://hanke8.cloud/tags/docker/"},{"name":"右值引用","slug":"右值引用","permalink":"http://hanke8.cloud/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"name":"《深度探索C++对象模型》","slug":"《深度探索C-对象模型》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"},{"name":"构造、析构函数可以是虚函数？","slug":"构造、析构函数可以是虚函数？","permalink":"http://hanke8.cloud/tags/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F/"},{"name":"inline内联函数","slug":"inline内联函数","permalink":"http://hanke8.cloud/tags/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"name":"《Effective C++》","slug":"《Effective-C-》","permalink":"http://hanke8.cloud/tags/%E3%80%8AEffective-C-%E3%80%8B/"},{"name":"c++引用的本质","slug":"c-引用的本质","permalink":"http://hanke8.cloud/tags/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/"},{"name":"拷贝构造函数参数","slug":"拷贝构造函数参数","permalink":"http://hanke8.cloud/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"},{"name":"文件描述符","slug":"文件描述符","permalink":"http://hanke8.cloud/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"name":"epolloneshot","slug":"epolloneshot","permalink":"http://hanke8.cloud/tags/epolloneshot/"},{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"},{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}