{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-11-12T14:27:59.046Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"个人主页纽约时间比加州时间早三个小时，New York is 3 hours ahead of California,但加州时间并没有变慢。but it does not make California slow.有人22岁就毕业了，Someone graduated at the age of 22,但等了五年才找到好的工作！but waited 5 years before securing a good job!有人25岁就当上CEO，Someone became a CEO at 25,却在50岁去世。and died at 50.也有人迟到50岁才当上CEO，While another became a CEO at 50,然后活到90岁。and lived to 90 years.有人依然单身，Someone is still single,同时也有人已婚。while someone else got married.奥巴马55岁就退休，Obama retires at 55,川普70岁才开始当总统。but Trump starts at 70.世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone.身边有些人看似走在你前面，People around you might seem to go ahead of you,也有人看似走在你后面。some might seem to be behind you但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them.他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours!生命就是等待正确的行动时机。Life is about waiting for the right moment to act.所以，放轻松。So, RELAX.你没有落后。You’re not LATE.你没有领先。You’re not EARLY.在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you."},{"title":"","date":"2021-05-11T15:21:13.968Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-05-16T13:35:43.711Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-05-16T06:31:42.097Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}