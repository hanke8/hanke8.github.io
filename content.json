{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-11-16T14:12:04.472Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"​ 灵台方寸山，斜月三星洞"},{"title":"","date":"2021-11-16T15:30:54.408Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"inline内联函数","slug":"inline内联函数","date":"2021-11-24T16:22:50.000Z","updated":"2021-11-24T16:41:59.951Z","comments":true,"path":"2021/11/25/inline内联函数/","link":"","permalink":"http://hanke8.cloud/2021/11/25/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","excerpt":"","text":"inline内联函数介绍 函数调用需要开栈 (分配内存、保存现场、准备参数、准备返回值)。 (假设某个函数经常被调用)为了解决频繁调用函数对栈内存重复开辟所带来的消耗，引入了inline修饰符，表示为内联函数。 编译器将内联函数内的代码复制到每一个使用它的地方。（有点像宏函数，但宏函数是预处理器来替换，不进行安全性检查） 用法 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。 1234567// 错误写法inline void Foo(int x, int y); // inline 仅与函数声明放在一起void Foo(int x, int y) &#123;&#125;// 正确写法void Foo(int x, int y);inline void Foo(int x, int y) &#123;&#125; // inline 与函数定义体放在一起 限制 inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数。 解释：内联函数不能是递归函数，因为内联函数是被编译器在编译的时候展开，而递归的深度在编译的时候无法确定。 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 参考 https://blog.csdn.net/zqixiao_09/article/details/50877383 https://blog.csdn.net/BjarneCpp/article/details/76044493 https://bbs.csdn.net/topics/90164538","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"inline内联函数","slug":"inline内联函数","permalink":"http://hanke8.cloud/tags/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"}]},{"title":"《Effective C++》第一章","slug":"Effective C++ 第一章","date":"2021-11-23T17:04:22.000Z","updated":"2021-11-23T17:51:58.694Z","comments":true,"path":"2021/11/24/Effective C++ 第一章/","link":"","permalink":"http://hanke8.cloud/2021/11/24/Effective%20C++%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"导读 默认的构造函数：要么没有参数，要么每个参数都有缺省值。 构造函数最好使用explicit关键字，阻止隐式类型转换(使代码更规范，防止意想不到的错误)。 拷贝构造函数的参数只能是传引用(不能是传值，也不能传指针)。解释 条款01 视 C++ 为一个语言联邦 C++ 是个多重范型编程语言：面向过程、面向对象、函数式、泛型、原编程式，所以他的规约很多，记住四个次语言可以帮助了解 C++：C、Object-Oriented C++、Template C++、STL。 条款02 尽量以 const、enum、inline 替换 #define 少用#define的理由如下： #define不会进行类型安全检查，#define AGE 25，AGE无类型，在进行预处理阶段只有AGE被替换成25的过程；而const int age = 25，age有类型(int)，在编译阶段会进行类型安全检查。 #define不提供封装性，即不存在private #define 这样的东东，无法用在class内部用#define定义class的专属常量；而class的常量可以用const来声明，比如static const int MAX_SIZE = 1024。 使用#define定义”宏函数”时，会出其不意的错误有时候，最好改用inline函数替换#define。 他们的根本差别是：前三者是编译器处理的，最后者是预处理器处理的。enum 比 const 更像 #define，比如说 const 定义通常可以求地址或引用，而 enum 不行。 inline 函数比宏多了类型安全和可预料性，一个例子是将 i++ 或 ++i 当参数传给宏时，可能导致 ++ 了多次，而传给 inline 函数则不会。 请记住： 对于单纯常量，最好使用const对象或者enum替代#define。 对于宏函数，最好使用inline函数替换。 条款03 尽可能使用 const const 可以帮助编译器侦测错误的用法。例如，令函数返回一个常量值，往往可降低因调用者错误而造成的意外，而又不至于放弃安全性和高效性。比如当比较语句少写了一个 = 时： 12// 本意是 ==，结果导致在 a * b 的临时变量上调用 operator=if (a * b = c) ... ​ 如果 operator= 返回值不是 const 会导致以上错误代码编译通过！ 条款04 确定对象被使用前已被初始化 c++规定初始化发生在进入构造函数之前。 1234567891011121314class A&#123;private: int x; int y; // 赋值 A() &#123; x = 0; // 注意！这是赋值不是初始化。（在进入构造函数之前就进行了初始化） y = 0; &#125; // 初始化 A(): x(0), y(0) &#123; // 这才是初始化，这样比赋值的效率高（因为赋值前就进行了初始化） &#125;&#125;; c++对于处于不同编译单元的non-local static对象的初始化相对顺序无明确定义。 注：local static对象是指在函数内声明定义的static对象，并通过该函数返回该对象的引用。 带来问题：比如两个源文件分别定义了non-local static对象a, b，其中a用到了b，此时b可能还未初始化。 解决方案：为避免跨编译单元的初始化次序问题，用 local static 对象代替 non-local static 对象，参考 Singleton 模式常见实现。 12345XClass&amp; GetInstance()&#123; static XClass instance; return instance;&#125; 参考 https://segmentfault.com/a/1190000038888539 《Effective C++》第一章","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Effective C++》","slug":"《Effective-C-》","permalink":"http://hanke8.cloud/tags/%E3%80%8AEffective-C-%E3%80%8B/"}]},{"title":"c++引用的本质","slug":"c-引用的本质","date":"2021-11-23T03:48:27.000Z","updated":"2021-11-23T03:55:05.259Z","comments":true,"path":"2021/11/23/c-引用的本质/","link":"","permalink":"http://hanke8.cloud/2021/11/23/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"C++ 引用的本质结论 引用的本质是一个指针常量 参考 一个reference通常是以一个指针来实现的，所以point和reference并没有本质的区别。– &lt;&lt;深度探索C++对象模型&gt;&gt; 注：Lippman 这里只是说通常的编译器实现，但是 C++标准并未给予保证。 引用的本质是一个指针常量(注意不是常量指针),指针常量的指向不可改而指向的值可以修改； 这也解释了引用为什么能够修改原来变量的值，修改值的唯一方法即是修改该地址对应的值。 – Google","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"c++引用的本质","slug":"c-引用的本质","permalink":"http://hanke8.cloud/tags/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/"}]},{"title":"拷贝构造函数参数","slug":"拷贝构造函数参数","date":"2021-11-22T10:28:06.000Z","updated":"2021-11-22T10:56:35.610Z","comments":true,"path":"2021/11/22/拷贝构造函数参数/","link":"","permalink":"http://hanke8.cloud/2021/11/22/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/","excerpt":"","text":"拷贝构造函数参数结论 拷贝构造函数的参数必须是引用 解释 为什么不能是传值？ 经典误区：或许你会回答为了减少一次内存拷贝？ 正解：传值的方式会继续调用拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。 为什么不能是传指针？ 拷贝构造函数需要传入的是一个对象，如果拷贝构造函数的参数是指针的话，这个参数就是地址而不是对象了(仅仅指向对象而已)。 所以不能用指针，作为拷贝构造函数的参数类型。 即写出传指针，那就不是拷贝构造函数了，编译器不认。 代码验证： 下面代码执行结果不会打印 ”拷贝构造函数“，说明func(a)调用的默认拷贝构造函数，即传指针的方式根本就不是拷贝构造函数。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt; // 万能头文件using namespace std;class A &#123;private: int data;public: A() &#123; cout &lt;&lt; &quot;构造函数&quot;&lt;&lt;endl; &#125; A(const A* a) &#123; data = a-&gt;data; cout &lt;&lt; &quot;拷贝构造函数&quot;&lt;&lt;endl; &#125; void func(A a) &#123; cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; A a; A b; a.func(b); return 0; &#125; 参考 https://blog.csdn.net/qq_35409955/article/details/72356370 https://www.codenong.com/cs109023805/","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"拷贝构造函数参数","slug":"拷贝构造函数参数","permalink":"http://hanke8.cloud/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"}]},{"title":"《深度探索C++对象模型》 第一章(关于对象)","slug":"深度探索C++对象模型 第一章","date":"2021-11-21T15:04:19.000Z","updated":"2021-11-23T17:52:29.250Z","comments":true,"path":"2021/11/21/深度探索C++对象模型 第一章/","link":"","permalink":"http://hanke8.cloud/2021/11/21/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"第一章 关于对象C++对象模式（The C++ Object Model）主题一个class对象在机器中是如何被表示的呢？ 分类 简单对象模型（A Simple Object Model） 表格驱动对象模型（A Table-driven Object Model） C++ 对象模型（The C++ Object Model） 简单对象模型（A Simple Object Model） 在简单模型中，一个object是一些的slots，每个slot指向一个members。Members按其声明此次序，各被指定一个slot，每一个data member或function member都有自己的一个slot。 简单理解起来就是，一个object被表示成了一个指针数组。 在这个简单模型中, members本身并不放在 object之中,只有“指向的指针”才放在 object内。这么做可以避免 ”members有不同的类型, 因而需要不同的存储空间“ 所招致的问题。 这个想法被应用到C++的 “指向成员的指针” 观念之中。 表格驱动对象模型（A Table-driven Object Model） object还是一个指针数组，不过存的是Member Data Table和Function Member Table两个表的地址。 这种模型保证了不同类型的对象具有相同的内存布局。 这个想法成为支持virtual functions的一个有效方案。 C++ 对象模型（The C++ Object Model） 在此模型中，Nonstatic data members被配置于每一个class object之内, static data members则被存放在所有的class object之外。Static和 nonstatic function members也被放在所有的class object之外, Virtual functions则以两个步骤支持之: 每一个 class产生出一堆指向 virtual functions的指针, 放在表格之中, 这个表格被称为 virtual table(vtbl)。 每一个 class obiect被添加了一个指针, 指向相关的 virtual table。 总结 ASOM和ATOM方法优点是object数据一致性(存的都是指针)，可以避免 ”members有不同的类型, 因而需要不同的存储空间“ 所招致的问题；缺点就是会带来间接性，使得存、取变得麻烦（特别是类继承时，如果在派生类里面存一个指向基类的指针）。 在C++中以类的形式实现对象之后，会增加多少布局成本？ 一般来说，不会增加任何成本。三个 data members 直接内含于一个 class object 中，就像 C 中的 struct 一样。而 member functions 虽然含在 class 的声明中，却不出现在 object 中 （更像是类命名空间中的普通函数）。看，类的封装居然没有带来任何额外的成本。 C++在内存布局以及存取时间上的主要额外负担都是由 virtual 引起的，包括： virtual function 机制：引起了保存 vtable 和透过 vtable 找到函数地址。 virtual base class 机制：引起了透过指针来找到基类的成员。 引入继承后的对象模型成本： 如果是普通的继承，父对象被直接包含在子对象里面，这样对父对象的存取也是直接进行的， 没有额外的成本。 如果是虚拟继承，则父对象会由一个指针被指出来，这样的话对父对象的存取就添加了一层间接性，必须经由一个指针来访问，添加了一次间接的额外成本。 一个对象的内存布局大小（通常由 3 部分组成）： 其 nonstatic data member 的总和大小。 任何由于字节对齐所需要的填补上去的空间。 加上了为了支持 virtual 机制而引起的额外负担。 这也印证了前面的一个结论：C++中的额外成本通常都是由于 virtual 机制所引起的。 多态的实现前言 指针类型、cast(类型转化)只影响编译器对内存的解释(大小和内容)。 实现方式 多态只能由指针或引用来实现，原因如下： 指针和引用（通常以指针来实现）的大小是固定的（一个 word），而对象的大小却是可变的。其类的指针和引用可以指向（或引用）子类，但是基类的对象永远也只能是基类，没有变化则不可能引发多态。 一个 point 或 reference 绝不会引发任何” “ 与类型有关的内存委托操作 ，在指针类型转换时 会受到的改变的只有它们所指向内存的解释方式而已。（例如指针绝不会引发 slice，因为它 们大小相同） 思考(加深理解)：","categories":[{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《深度探索C++对象模型》","slug":"《深度探索C-对象模型》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"}]},{"title":"文件描述符","slug":"文件描述符","date":"2021-11-19T13:05:39.000Z","updated":"2021-11-19T13:22:03.146Z","comments":true,"path":"2021/11/19/文件描述符/","link":"","permalink":"http://hanke8.cloud/2021/11/19/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"Linux文件描述符的本质大致认识文件描述符是文件编号。 Linux 中一切皆文件，比如 C++ 源文件、视频文件、Shell脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。 一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为文件描述符（File Descriptor）。 进一步认识文件描述符是PCB内部文件描述符表的下标，与文件指针一一映射。 一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。 除了文件描述符表，系统还需要维护另外两张表： 打开文件表（Open file table） i-node 表（i-node table） 参考 http://c.biancheng.net/view/3066.html","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"文件描述符","slug":"文件描述符","permalink":"http://hanke8.cloud/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"}]},{"title":"epolloneshot事件","slug":"epolloneshot事件","date":"2021-11-19T12:17:37.000Z","updated":"2021-11-19T12:37:29.927Z","comments":true,"path":"2021/11/19/epolloneshot事件/","link":"","permalink":"http://hanke8.cloud/2021/11/19/epolloneshot%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"epoll - ET触发模式 - epolloneshot事件背景对于同一批数据我们希望在一个线程里面处理，不然容易造成混乱。 问题epoll模型的ET模式一般来说只触发一次，然而在并发程序中有特殊情况的存在，譬如当epoll_wait已经检测到socket描述符fd1，并通知应用程序处理fd1的数据，那么处理过程中该fd1又有新的数据可读，会唤醒其他线程对fd1进行操作，那么就出现了两个工作线程同时处理fd1的情况，这当然不是我们期望看到的。 解决方案epolloneshot事件，规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符。当然处理完之后线程要重置这个epolloneshot事件，进而当此描述符有事件可读时让其他进程可以处理此描述符。 关键代码1234567891011121314151617// 工作线程while( 1 ) &#123; int ret = recv( sockfd, buf, BUFFER_SIZE-1, 0 ); if( ret == 0 ) &#123; // 客户端关闭连接 close( sockfd ); printf( &quot;client closed the connection\\n&quot; ); break; &#125; else if( ret &lt; 0 ) &#123; if( errno == EAGAIN ) &#123; // 数据被读完 resetOneshot( epollfd, sockfd ); // 重置Oneshot事件 printf( &quot;read later\\n&quot; ); break; &#125; &#125; else ...略&#125; 参考 https://blog.csdn.net/hnlyyk/article/details/50946655 https://www.cnblogs.com/kex1n/p/7451069.html","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"epolloneshot","slug":"epolloneshot","permalink":"http://hanke8.cloud/tags/epolloneshot/"}]},{"title":"端口复用","slug":"端口复用","date":"2021-11-17T08:07:32.000Z","updated":"2021-11-17T08:19:08.883Z","comments":true,"path":"2021/11/17/端口复用/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/","excerpt":"","text":"端口复用背景 默认的情况下，一个端口只能被一个套接字绑定；如果一个网络应用程序的一个套接字绑定了一个端口( 占用了 8000 )，这时候，别的套接字就无法使用这个端口( 8000 )； 因为多个应用程序占用一个端口，容易发生混乱； 应用场景 （1）服务器只对外开放某一端口（80端口或其他任意少量端口），其他端口全部被封死（2）为了躲避防火墙（3）隐藏自己后门（4）转发不出端口（5）内网渗透 端口复用最常用的用途应该是防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中——那只好等等再重试了，麻烦！ 如何使用 设置socket的SO_REUSEADDR选项，即可实现端口复用： 123int opt = 1;// sockfd为需要端口复用的套接字setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;opt, sizeof(opt)); 注意点 端口复用允许在一个应用程序可以把 n 个套接字绑在一个端口上而不出错。同时，这 n 个套接字发送信息都正常，没有问题。但是，这些套接字并不是所有都能读取信息，只有最后一个套接字会正常接收数据。 端口复用的原理是与源端口占用程序监听同一端口，当复用端口有数据来时，我们可以判断是否是自己的数据包，如果是自己的，那么就自己处理，否则把数据包交给源端口占用程序处理。 在这里有个问题就是，如果你不处理数据包的归属问题的话，那么这个端口就会被端口复用程序占用，从而导致源端口占用程序无法工作。 参考 https://blog.csdn.net/tennysonsky/article/details/44062173 https://juejin.cn/post/6844903509624651790#heading-4","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"}]},{"title":"状态压缩","slug":"状态压缩","date":"2021-11-17T06:44:46.000Z","updated":"2021-11-17T07:02:08.017Z","comments":true,"path":"2021/11/17/状态压缩/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"状态压缩基本思路 用二进制表示状态 位运算 LC318.最大单词长度乘积 遍历所有的单词对，判断他们是否有同样的字母出现； 传统的做法就是用一个长度为26的数组记录每个单词出现了哪些字符；每次比较遍历复杂度是26，乘以遍历单词对O(n^2)复杂度，可能就会超时了； 一个优化的方式就是采用状态压缩，我们将每一个字母是否出现在某个单词的状态用一个int表示， int的每一位代表a-z中的每个字母是否出现过; 123456789101112131415161718192021222324252627class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; // 状态压缩： // 用一个26位的int表示每个字符是否出现。(比如...101 表示&#x27;c&#x27;和&#x27;a&#x27;出现过) // 之后再用 &amp; 运算即可知道是否有相同字符 int n = words.size(); vector&lt;int&gt; status(n, 0); for(int i = 0; i &lt; n; i++) &#123; for(char&amp; ch : words[i]) &#123; status[i] |= 1 &lt;&lt; (ch-&#x27;a&#x27;); // ch相应的位置置1 &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if( (status[i] &amp; status[j]) == 0) &#123; // &amp; 为0，表示没有相同的字符 int len = words[i].length() * words[j].length(); res = max(res, len); &#125; &#125; &#125; return res; &#125;&#125;; 复杂度：O(L+n^2)，L是全部单词长度之和;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"0-1背包","slug":"0-1背包","date":"2021-11-16T15:06:50.000Z","updated":"2021-11-16T15:37:14.927Z","comments":true,"path":"2021/11/16/0-1背包/","link":"","permalink":"http://hanke8.cloud/2021/11/16/0-1%E8%83%8C%E5%8C%85/","excerpt":"","text":"动态规划背包问题基本思路 常见于题型：考虑每个物品选或者不选； dp[i] [j] 一般定义成：前i个物品中，容量为j，怎么样； LC416.分割等和子集 看数据范围可知，dfs必定超时； 一般dfs搜索可以解决的问题，动态规划也能解决； (个人认为动态规划的本质也是搜索，基本等价于记忆化dfs) 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 动态规划：0-1背包，从前i个物品里是否能挑出刚好容量为sum/2 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(sum/2 + 1, false)); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[0][nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; // 复杂度：O(NM) M为sum/2 for(int j = 1; j &lt;= sum / 2; j++) &#123; if(nums[i] == j) &#123; dp[i][j] = true; continue; &#125; if(dp[i-1][j]) dp[i][j] = true; // 更新dp[i][j] else if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true; // 更新dp[i][j] &#125; if(dp[i][sum/2]) return true; &#125; return dp[n-1][sum/2]; &#125;&#125;; 优化： 从上面可以看出，dp[i] [j]仅于dp[i-1] [j]和dp[i-1] [j-nums[i]]有关，因此只要保存上一行即可； 进一步可以从二维优化到一维，逆序更新即可；即用当前行覆盖上一行数据；(看代码就容易明白了) 1234567891011121314151617181920212223242526class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 二维0-1背包优化成1维度; // (因为dp[i][j]仅于dp[i-1][j]和dp[i-1][j-nums[i]]有关) // (即当前行的更新仅于上一行的两个元素有关) 因此倒序更新即可 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;bool&gt; dp(sum/2 + 1, false); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; for(int j = sum/2; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j-nums[i]]; // 当前行的dp[j], 利用上一行的dp[j]和dp[j-nums[i]]来更新 &#125; if(dp[sum/2]) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"}]},{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-11-16T15:36:52.108Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-11-16T15:34:38.638Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"},{"name":"书籍","slug":"书籍","permalink":"http://hanke8.cloud/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://hanke8.cloud/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"inline内联函数","slug":"inline内联函数","permalink":"http://hanke8.cloud/tags/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"name":"《Effective C++》","slug":"《Effective-C-》","permalink":"http://hanke8.cloud/tags/%E3%80%8AEffective-C-%E3%80%8B/"},{"name":"c++引用的本质","slug":"c-引用的本质","permalink":"http://hanke8.cloud/tags/c-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/"},{"name":"拷贝构造函数参数","slug":"拷贝构造函数参数","permalink":"http://hanke8.cloud/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"},{"name":"《深度探索C++对象模型》","slug":"《深度探索C-对象模型》","permalink":"http://hanke8.cloud/tags/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"},{"name":"文件描述符","slug":"文件描述符","permalink":"http://hanke8.cloud/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"name":"epolloneshot","slug":"epolloneshot","permalink":"http://hanke8.cloud/tags/epolloneshot/"},{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"},{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}