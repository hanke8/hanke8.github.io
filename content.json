{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-11-16T14:12:04.472Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"​ 灵台方寸山，斜月三星洞"},{"title":"","date":"2021-11-16T15:30:54.408Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"0-1背包","slug":"0-1背包","date":"2021-11-16T15:06:50.000Z","updated":"2021-11-16T15:34:18.602Z","comments":true,"path":"2021/11/16/0-1背包/","link":"","permalink":"http://hanke8.cloud/2021/11/16/0-1%E8%83%8C%E5%8C%85/","excerpt":"","text":"动态规划背包问题基本思路 常见于题型：考虑每个物品选或者不选； dp[i] [j] 一般定义成：前i个物品中，容量为j，怎么样 LC416.分割等和子集 看数据范围可知，dfs必定超时； 一般dfs搜索可以解决的问题，动态规划也能解决(个人认为动态规划的本质也是搜索，基本等价于记忆化dfs)； 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 动态规划：0-1背包，从前i个物品里是否能挑出刚好容量为sum/2 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(sum/2 + 1, false)); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[0][nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; // 复杂度：O(NM) M为sum/2 for(int j = 1; j &lt;= sum / 2; j++) &#123; if(nums[i] == j) &#123; dp[i][j] = true; continue; &#125; if(dp[i-1][j]) dp[i][j] = true; // 更新dp[i][j] else if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true; // 更新dp[i][j] &#125; if(dp[i][sum/2]) return true; &#125; return dp[n-1][sum/2]; &#125;&#125;; 优化： 从上面可以看出，dp[i] [j]仅于dp[i-1] [j]和dp[i-1] [j-nums[i]]有关，因此只要保存上一行即可； 进一步可以从二维优化到一维，逆序更新即可；即用当前行覆盖上一行数据；(看代码就容易明白了) 1234567891011121314151617181920212223242526class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 二维0-1背包优化成1维度; // (因为dp[i][j]仅于dp[i-1][j]和dp[i-1][j-nums[i]]有关) // (即当前行的更新仅于上一行的两个元素有关) 因此倒序更新即可 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;bool&gt; dp(sum/2 + 1, false); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; for(int j = sum/2; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j-nums[i]]; // 当前行的dp[j], 利用上一行的dp[j]和dp[j-nums[i]]来更新 &#125; if(dp[sum/2]) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"}]},{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-11-16T15:34:29.214Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-11-16T15:34:38.638Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"},{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}