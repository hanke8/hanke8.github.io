{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-11-16T14:12:04.472Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"​ 灵台方寸山，斜月三星洞"},{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-16T15:30:54.408Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"端口复用","slug":"端口复用","date":"2021-11-17T08:07:32.000Z","updated":"2021-11-17T08:19:08.883Z","comments":true,"path":"2021/11/17/端口复用/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/","excerpt":"","text":"端口复用背景 默认的情况下，一个端口只能被一个套接字绑定；如果一个网络应用程序的一个套接字绑定了一个端口( 占用了 8000 )，这时候，别的套接字就无法使用这个端口( 8000 )； 因为多个应用程序占用一个端口，容易发生混乱； 应用场景 （1）服务器只对外开放某一端口（80端口或其他任意少量端口），其他端口全部被封死（2）为了躲避防火墙（3）隐藏自己后门（4）转发不出端口（5）内网渗透 端口复用最常用的用途应该是防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中——那只好等等再重试了，麻烦！ 如何使用 设置socket的SO_REUSEADDR选项，即可实现端口复用： 123int opt = 1;// sockfd为需要端口复用的套接字setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;opt, sizeof(opt)); 注意点 端口复用允许在一个应用程序可以把 n 个套接字绑在一个端口上而不出错。同时，这 n 个套接字发送信息都正常，没有问题。但是，这些套接字并不是所有都能读取信息，只有最后一个套接字会正常接收数据。 端口复用的原理是与源端口占用程序监听同一端口，当复用端口有数据来时，我们可以判断是否是自己的数据包，如果是自己的，那么就自己处理，否则把数据包交给源端口占用程序处理。 在这里有个问题就是，如果你不处理数据包的归属问题的话，那么这个端口就会被端口复用程序占用，从而导致源端口占用程序无法工作。 参考 https://blog.csdn.net/tennysonsky/article/details/44062173 https://juejin.cn/post/6844903509624651790#heading-4","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"}]},{"title":"状态压缩","slug":"状态压缩","date":"2021-11-17T06:44:46.000Z","updated":"2021-11-17T07:02:08.017Z","comments":true,"path":"2021/11/17/状态压缩/","link":"","permalink":"http://hanke8.cloud/2021/11/17/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"状态压缩基本思路 用二进制表示状态 位运算 LC318.最大单词长度乘积 遍历所有的单词对，判断他们是否有同样的字母出现； 传统的做法就是用一个长度为26的数组记录每个单词出现了哪些字符；每次比较遍历复杂度是26，乘以遍历单词对O(n^2)复杂度，可能就会超时了； 一个优化的方式就是采用状态压缩，我们将每一个字母是否出现在某个单词的状态用一个int表示， int的每一位代表a-z中的每个字母是否出现过; 123456789101112131415161718192021222324252627class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; // 状态压缩： // 用一个26位的int表示每个字符是否出现。(比如...101 表示&#x27;c&#x27;和&#x27;a&#x27;出现过) // 之后再用 &amp; 运算即可知道是否有相同字符 int n = words.size(); vector&lt;int&gt; status(n, 0); for(int i = 0; i &lt; n; i++) &#123; for(char&amp; ch : words[i]) &#123; status[i] |= 1 &lt;&lt; (ch-&#x27;a&#x27;); // ch相应的位置置1 &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if( (status[i] &amp; status[j]) == 0) &#123; // &amp; 为0，表示没有相同的字符 int len = words[i].length() * words[j].length(); res = max(res, len); &#125; &#125; &#125; return res; &#125;&#125;; 复杂度：O(L+n^2)，L是全部单词长度之和;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"0-1背包","slug":"0-1背包","date":"2021-11-16T15:06:50.000Z","updated":"2021-11-16T15:37:14.927Z","comments":true,"path":"2021/11/16/0-1背包/","link":"","permalink":"http://hanke8.cloud/2021/11/16/0-1%E8%83%8C%E5%8C%85/","excerpt":"","text":"动态规划背包问题基本思路 常见于题型：考虑每个物品选或者不选； dp[i] [j] 一般定义成：前i个物品中，容量为j，怎么样； LC416.分割等和子集 看数据范围可知，dfs必定超时； 一般dfs搜索可以解决的问题，动态规划也能解决； (个人认为动态规划的本质也是搜索，基本等价于记忆化dfs) 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 动态规划：0-1背包，从前i个物品里是否能挑出刚好容量为sum/2 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(sum/2 + 1, false)); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[0][nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; // 复杂度：O(NM) M为sum/2 for(int j = 1; j &lt;= sum / 2; j++) &#123; if(nums[i] == j) &#123; dp[i][j] = true; continue; &#125; if(dp[i-1][j]) dp[i][j] = true; // 更新dp[i][j] else if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true; // 更新dp[i][j] &#125; if(dp[i][sum/2]) return true; &#125; return dp[n-1][sum/2]; &#125;&#125;; 优化： 从上面可以看出，dp[i] [j]仅于dp[i-1] [j]和dp[i-1] [j-nums[i]]有关，因此只要保存上一行即可； 进一步可以从二维优化到一维，逆序更新即可；即用当前行覆盖上一行数据；(看代码就容易明白了) 1234567891011121314151617181920212223242526class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; // 二维0-1背包优化成1维度; // (因为dp[i][j]仅于dp[i-1][j]和dp[i-1][j-nums[i]]有关) // (即当前行的更新仅于上一行的两个元素有关) 因此倒序更新即可 int n = nums.size(); if(n == 1) return false; int sum = 0; for(int&amp; x : nums) sum += x; if(sum % 2 != 0) return false; vector&lt;bool&gt; dp(sum/2 + 1, false); if(nums[0] == sum / 2) return true; if(nums[0] &lt; sum / 2) dp[nums[0]] = true; for(int i = 1; i &lt; n; i++) &#123; for(int j = sum/2; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j-nums[i]]; // 当前行的dp[j], 利用上一行的dp[j]和dp[j-nums[i]]来更新 &#125; if(dp[sum/2]) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"}]},{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-11-16T15:36:52.108Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-11-16T15:34:38.638Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hanke8.cloud/categories/%E6%9D%82%E8%B0%88/"},{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"端口复用","slug":"端口复用","permalink":"http://hanke8.cloud/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://hanke8.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"0-1背包","slug":"0-1背包","permalink":"http://hanke8.cloud/tags/0-1%E8%83%8C%E5%8C%85/"},{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}