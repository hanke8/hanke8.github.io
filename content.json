{"meta":{"title":"Hanke's Blog","subtitle":"心之所向，素履以往","description":"","author":"Hanke","url":"http://hanke8.cloud","root":"/"},"pages":[{"title":"about","date":"2021-05-12T07:06:48.000Z","updated":"2021-05-12T07:20:41.064Z","comments":false,"path":"about/index.html","permalink":"http://hanke8.cloud/about/index.html","excerpt":"","text":"个人主页~ 第一章 · 内容 ~第二章 ·内容"},{"title":"","date":"2021-05-11T15:21:13.968Z","updated":"2021-05-11T15:21:13.968Z","comments":false,"path":"tags/index.html","permalink":"http://hanke8.cloud/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-11T15:23:01.706Z","updated":"2021-05-11T15:23:01.706Z","comments":false,"path":"categories/index.html","permalink":"http://hanke8.cloud/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"离谱","slug":"离谱","date":"2021-11-12T13:04:24.000Z","updated":"2021-11-12T13:04:24.445Z","comments":true,"path":"2021/11/12/离谱/","link":"","permalink":"http://hanke8.cloud/2021/11/12/%E7%A6%BB%E8%B0%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"“test1”","slug":"“test1”","date":"2021-11-12T13:03:50.000Z","updated":"2021-11-12T13:03:50.082Z","comments":true,"path":"2021/11/12/“test1”/","link":"","permalink":"http://hanke8.cloud/2021/11/12/%E2%80%9Ctest1%E2%80%9D/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"测试","slug":"测试","date":"2021-11-12T12:59:47.000Z","updated":"2021-11-12T12:59:47.819Z","comments":true,"path":"2021/11/12/测试/","link":"","permalink":"http://hanke8.cloud/2021/11/12/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"leetcode78.子集-求子集的两个模板","slug":"leetcode78-子集-求子集的两个模板","date":"2021-05-16T12:29:56.000Z","updated":"2021-05-16T13:35:43.711Z","comments":true,"path":"2021/05/16/leetcode78-子集-求子集的两个模板/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"题目 解法1：二进制状态编码分析· 原序列中的每个数字有两种状态：在子集中、不在子集中；· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];· 例如集合{5，2，9}： 代码1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); for(int mask=0; mask &lt; (1&lt;&lt;n); mask++) // 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; if(mask &amp; (1&lt;&lt;i)) v.push_back(nums[i]); &#125; res.push_back(v); &#125; return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。 解法2：回溯法分析· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; void dfs(int curPosition,vector&lt;int&gt; &amp;nums) &#123; if(curPosition == nums.size()) &#123; res.push_back(temp); return; &#125; //当前位置的数在子集中 temp.push_back(nums[curPosition]); dfs(curPosition+1, nums); temp.pop_back(); //当前位置的数不在子集中 dfs(curPosition+1, nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; dfs(0, nums); return res; &#125;&#125;; 复杂度分析· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。 · 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"}]},{"title":"leetcode第241场周赛","slug":"leetcode第241场周赛","date":"2021-05-16T04:13:39.000Z","updated":"2021-05-16T06:31:42.097Z","comments":true,"path":"2021/05/16/leetcode第241场周赛/","link":"","permalink":"http://hanke8.cloud/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"题目1： 知识点：如何求子集代码123456789101112131415class Solution &#123;public: int subsetXORSum(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); int ans =0 ; for(int msk = 0; msk &lt; ((1 &lt;&lt; n)); msk++) &#123; int x = 0; for(int i = 0; i &lt; n; i++) &#123; if((msk &gt;&gt; i) &amp; 1) x ^= a[i]; &#125; ans += x; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://hanke8.cloud/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制状态编码 回溯","slug":"二进制状态编码-回溯","permalink":"http://hanke8.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81-%E5%9B%9E%E6%BA%AF/"},{"name":"leetcode周赛","slug":"leetcode周赛","permalink":"http://hanke8.cloud/tags/leetcode%E5%91%A8%E8%B5%9B/"}]}