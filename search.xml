<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode78.子集-求子集的两个模板</title>
    <url>/2021/05/16/leetcode78-%E5%AD%90%E9%9B%86-%E6%B1%82%E5%AD%90%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="../images/blogImg/lc78_problem.png" alt="题目"></p>
<h2 id="解法1：二进制状态编码"><a href="#解法1：二进制状态编码" class="headerlink" title="解法1：二进制状态编码"></a>解法1：二进制状态编码</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>· 原序列中的每个数字有两种状态：在子集中、不在子集中；<br>· 我们用n位二进制序列来表示每个数字的状态，若某数字在子集中，则二进制序列对应位置位1，否则为0;<br>· 二进制序列的每一个位置有0，1两种可能，所以总共可能的情况为2^n种，对应十进制数的[0, 2^n-1];<br>· 例如集合{5，2，9}：</p>
<p><img src="../images/blogImg/lc78_ans.png" alt="举例"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask=<span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span>&lt;&lt;n); mask++) <span class="hljs-comment">// 1&lt;&lt;n表示将1左移n位，即2的n次方(2^n)</span><br>        &#123;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(mask &amp; (<span class="hljs-number">1</span>&lt;&lt;i)) v.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。</p>
<p>· 空间复杂度：O(n)，构造子集使用的临时数组v的空间代价。</p>
<h2 id="解法2：回溯法"><a href="#解法2：回溯法" class="headerlink" title="解法2：回溯法"></a>解法2：回溯法</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>· 每个位置的数字可能在子集中，也可能不在子集中，因此我们只需要对每个位置的这两种情况进行搜索就行。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curPosition,vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(curPosition == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前位置的数在子集中</span><br>        temp.<span class="hljs-built_in">push_back</span>(nums[curPosition]);<br>        <span class="hljs-built_in">dfs</span>(curPosition+<span class="hljs-number">1</span>, nums);<br>        temp.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">//当前位置的数不在子集中</span><br>        <span class="hljs-built_in">dfs</span>(curPosition+<span class="hljs-number">1</span>, nums);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>· 时间复杂度：O(n*2^n)，一共2^n个状态，每种状态需要O(n)的时间来构造子集。</p>
<p>· 空间复杂度：O(n)，构造子集使用的临时数组temp的空间代价。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二进制状态编码 回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包</title>
    <url>/2021/11/16/0-1%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h3 id="动态规划背包问题"><a href="#动态规划背包问题" class="headerlink" title="动态规划背包问题"></a>动态规划背包问题</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>常见于题型：考虑每个物品选或者不选；</li>
<li>dp[i] [j] 一般定义成：前i个物品中，容量为j，怎么样</li>
</ul>
<h4 id="LC416-分割等和子集"><a href="#LC416-分割等和子集" class="headerlink" title="LC416.分割等和子集"></a>LC416.分割等和子集</h4><p><img src="../images/blogImg/lc416.png" alt="题目描述"></p>
<ul>
<li>看数据范围可知，dfs必定超时；</li>
<li>一般dfs搜索可以解决的问题，动态规划也能解决(个人认为动态规划的本质也是搜索，基本等价于记忆化dfs)；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 动态规划：0-1背包，从前i个物品里是否能挑出刚好容量为sum/2</span><br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; x : nums) sum += x;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">bool</span>&gt;(sum/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] == sum / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt; sum / <span class="hljs-number">2</span>) dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;				<span class="hljs-comment">// 复杂度：O(NM) M为sum/2</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= sum / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == j) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j]) dp[i][j] = <span class="hljs-literal">true</span>;		<span class="hljs-comment">// 更新dp[i][j]</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j-nums[i]&gt;=<span class="hljs-number">0</span> &amp;&amp; dp[i<span class="hljs-number">-1</span>][j-nums[i]]) dp[i][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 更新dp[i][j]</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i][sum/<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][sum/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>优化：</p>
<ul>
<li>从上面可以看出，dp[i] [j]仅于dp[i-1] [j]和dp[i-1] [j-nums[i]]有关，因此只要保存上一行即可；</li>
<li>进一步可以从二维优化到一维，逆序更新即可；即用当前行覆盖上一行数据；(看代码就容易明白了)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 二维0-1背包优化成1维度; </span><br>        <span class="hljs-comment">// (因为dp[i][j]仅于dp[i-1][j]和dp[i-1][j-nums[i]]有关)</span><br>        <span class="hljs-comment">// (即当前行的更新仅于上一行的两个元素有关) 因此倒序更新即可</span><br>        <br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; x : nums) sum += x;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] == sum / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt; sum / <span class="hljs-number">2</span>) dp[nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = sum/<span class="hljs-number">2</span>; j &gt;= nums[i]; j--) &#123;<br>                dp[j] = dp[j] || dp[j-nums[i]];     <span class="hljs-comment">// 当前行的dp[j], 利用上一行的dp[j]和dp[j-nums[i]]来更新</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[sum/<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>0-1背包</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第241场周赛</title>
    <url>/2021/05/16/leetcode%E7%AC%AC241%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h2><p><img src="C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20210516121804630.png" alt="题目1"></p>
<h3 id="知识点：如何求子集"><a href="#知识点：如何求子集" class="headerlink" title="知识点：如何求子集"></a>知识点：如何求子集</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subsetXORSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> msk = <span class="hljs-number">0</span>; msk &lt; ((<span class="hljs-number">1</span> &lt;&lt; n)); msk++) &#123;<br>            <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span>((msk &gt;&gt; i) &amp; <span class="hljs-number">1</span>) x ^= a[i];<br>            &#125;<br>            ans += x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode周赛</tag>
      </tags>
  </entry>
</search>
